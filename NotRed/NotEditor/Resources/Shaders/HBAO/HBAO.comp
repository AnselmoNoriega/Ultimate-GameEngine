#version 450

#define AO_RANDOMTEX_SIZE 4


layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 19, rgba16f) restrict writeonly uniform image2DArray outputTexture;


layout(std140, binding = 18) uniform HBAOData
{
	vec4    uFloat2Offsets[16];
	vec4    uJitters[16];
	vec4	uPerspectiveInfo;   // R = (x) * (R - L)/N \\\\\\ G = (y) * (T - B)/N \\\\\\ B =  L/N \\\\\\ A =  B/N
	vec2    uInvQuarterResolution;
	float   uRadiusToScreen;        // radius
	float   uNegInvR2;     // radius * radius
	float   uNDotVBias;
	float   uAOMultiplier;
	float   uPowExponent;
	bool	uIsOrtho;
};

layout(binding = 0) uniform sampler2DArray uLinearDepthTexArray;
layout(binding = 1) uniform sampler2D uViewNormalsTex;
layout(binding = 2) uniform sampler2D uViewPositionTex;

// The pragma below is critical for optimal performance
// in this fragment shader to let the shader compiler
// fully optimize the maths and batch the texture fetches
// optimally

#pragma optionNV(unroll all)


#define M_PI 3.14159265f

// tweakables
const float  NUM_STEPS = 4;
const float  NUM_DIRECTIONS = 8; // texRandom/g_Jitter initialization depends on this



vec2 g_Float2Offset = uFloat2Offsets[gl_WorkGroupID.z].xy;
vec4 g_Jitter = uJitters[gl_WorkGroupID.z];


vec3 getQuarterCoord(vec2 UV) {
	return vec3(UV, float(gl_WorkGroupID.z));
}


//----------------------------------------------------------------------------------

vec3 UVToView(vec2 uv, float eye_z)
{
	return vec3((uv * uPerspectiveInfo.xy + uPerspectiveInfo.zw) * (uIsOrtho ? 1.0 : eye_z), eye_z);
}


vec3 FetchQuarterResViewPos(vec2 UV)
{
	float ViewDepth = textureLod(uLinearDepthTexArray, getQuarterCoord(UV), 0).x;
	return UVToView(UV, ViewDepth);
}

//----------------------------------------------------------------------------------

float Falloff(float DistanceSquare)
{
	// 1 scalar mad instruction
	return DistanceSquare * uNegInvR2 + 1.0;
}

//----------------------------------------------------------------------------------
// P = view-space position at the kernel center
// N = view-space normal at the kernel center
// S = view-space position of the current sample
//----------------------------------------------------------------------------------
float ComputeAO(vec3 P, vec3 N, vec3 S)
{
	vec3 V = S - P;
	float VdotV = dot(V, V);
	float NdotV = dot(N, V) * 1.0 / sqrt(VdotV);

	// Use saturate(x) instead of max(x,0.f) because that is faster on Kepler
	return clamp(NdotV - uNDotVBias, 0, 1) * clamp(Falloff(VdotV), 0, 1);
}

//----------------------------------------------------------------------------------
vec2 RotateDirection(vec2 Dir, vec2 CosSin)
{
	return vec2(Dir.x * CosSin.x - Dir.y * CosSin.y,
		Dir.x * CosSin.y + Dir.y * CosSin.x);
}

//----------------------------------------------------------------------------------
vec4 GetJitter()
{
	// Get the current jitter vector from the per-pass constant buffer
	return g_Jitter;
}

//----------------------------------------------------------------------------------
float ComputeCoarseAO(vec2 FullResUV, float RadiusPixels, vec4 Rand, vec3 ViewPosition, vec3 ViewNormal)
{
	RadiusPixels /= 4.0;

	// Divide by NUM_STEPS+1 so that the farthest samples are not fully attenuated

	float StepSizePixels = RadiusPixels / (NUM_STEPS + 1);

	const float Alpha = 2.0 * M_PI / NUM_DIRECTIONS;
	float AO = 0;
	for (float DirectionIndex = 0; DirectionIndex < NUM_DIRECTIONS; ++DirectionIndex)
	{
		float Angle = Alpha * DirectionIndex;


		// Compute normalized 2D direction
		vec2 Direction = RotateDirection(vec2(cos(Angle), sin(Angle)), Rand.xy);

		// Jitter starting sample within the first step
		float RayPixels = (Rand.z * StepSizePixels + 1.0);

		for (float StepIndex = 0; StepIndex < NUM_STEPS; ++StepIndex)
		{
			vec2 SnappedUV = round(RayPixels * Direction) * uInvQuarterResolution + FullResUV;
			vec3 S = FetchQuarterResViewPos(SnappedUV);
			RayPixels += StepSizePixels;

			AO += ComputeAO(ViewPosition, ViewNormal, S);
		}
	}
	AO *= uAOMultiplier / (NUM_DIRECTIONS * NUM_STEPS);
	return (clamp(1.0 - AO * 2.0, 0, 1));
}

//----------------------------------------------------------------------------------
void main()
{

	vec2 base = gl_GlobalInvocationID.xy / vec2(imageSize(outputTexture));
	vec2 uv = 2.0 * vec2(base.x, 1.0 - base.y) - vec2(1.0);

	vec3 ViewPosition = texelFetch(uViewPositionTex, ivec2(base), 0).xyz;
	ViewPosition.z = -ViewPosition.z;
	vec3 NormalAndAO = texelFetch(uViewNormalsTex, ivec2(base), 0).xyz;
	vec3 ViewNormal = -(NormalAndAO.xyz * 2.0 - 1.0);

	// Compute projection of disk of radius control.R into screen space
	float RadiusPixels = uRadiusToScreen / (uIsOrtho ? 1.0 : ViewPosition.z);

	// Get jitter vector for the current full-res pixel
	vec4 Rand = GetJitter();

	float AO = ComputeCoarseAO(uv, RadiusPixels, Rand, ViewPosition, ViewNormal);

	//out_Color = vec4(pow(AO, uPowExponent), ViewPosition.z, 0, 1);
	imageStore(outputTexture, ivec3(gl_GlobalInvocationID), vec4(pow(AO, uPowExponent), ViewPosition.z, 0, 1));

}

